<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{margin: 0;padding: 0;}
        .black{width: 200px;height: 170px;background-color: black;margin-left: 200px;padding-top: 30px;}
        .green{width: 160px;height: 120px;background-color: green;margin: auto;padding-top: 20px;}
        .blue{width: 120px;height: 100px;background-color: blue;margin: auto;}
    </style>
</head>
<body>
    <!-- 本例子要用火狐浏览器 -->
    <div class="black">
        <div class="green">
            <div class="blue"></div>
        </div>
    </div>
    <script>
        //冒泡的核心问题在于当三个标签块同时点击时，为什么标签最里层的块会最先触发，也就是说触发的顺序是从里到外的
        // 所谓冒泡的形象，就是从里往外的过程
        
        /*
        var divs=document.getElementsByTagName("div");
            for(var i=0;i<divs.length;i++){
                divs[i].onclick=function(){
                    // console.log(i)
                    // 以上仍然是打印出3，也就是说i是一个全局变量
                    // 所以如果方法体为 divs[i].style.background="yellow"，是会出错的
                    this.style.background="yellow"
                    // console.log(i) 方法体里面就没有i的事，也不需要。
                    // 选项卡的例子是需要用同一个序号绑定两个界面
                    // 所以需要一个创造一个index属性存一下“当点击事件发生时的那个序号”
                    alert(this.className)
                    // alert的特性就是不点确定，代码不往下执行
                    this.style.background=""
                    // 背景颜色设置为空，本质上方法体里的背景色设置都是给标签设置内联样式
                    // 内联样式优先级高于外部样式，所以会覆盖，而内联样式为空的时候，由回到服从外部样式的状态
                }
            }
        */

        // 如果用addEventListener的方法重构上述代码，用来体现这个方法第三个参数的作用
        
        /*
        var divs=document.getElementsByTagName("div");
            for(var i=0;i<divs.length;i++){
                divs[i].addEventListener("click",function(){
                    this.style.background="yellow"
                    alert(this.className)
                    this.style.background=""
                },false)
            }
        */
        
        
        
        /*
        上述的false如果改为true，则就意味着“事件在捕获阶段触发”
        在点击中间蓝色块的时候，最先改变的是外层的黑色块，执行顺序变成了从外向里
        一般时候是需要点击谁，谁触发，所以一般不选择true
        */


        var divs=document.getElementsByTagName("div");
            for(var i=0;i<divs.length;i++){
                divs[i].addEventListener("click",function(e){
                    e.target.style.background="yellow"
                    alert(e.target.className)
                    e.target.style.background=""
                    e.stopPropagation()
                },false)
            } 
        /*
        

        关于阻止冒泡，比如在一个banner图里面有一个报名的按钮
        如果不阻止冒泡，则点了报名按钮后，banner图的事件也会触发
        事件对象event：由传入函数的第一个参数决定
        e.stopPropagation()

        针对IE的写法
        e.cancelBubble=true
        这里的“e”就是“事件对象”
        事件对象的其他用法 
        e.offsetX
        e.offsetY

        e.target事件源对象
        并不是用来阻止冒泡，但是可以准确地找到事件源
        */



    </script>
</body>
</html>