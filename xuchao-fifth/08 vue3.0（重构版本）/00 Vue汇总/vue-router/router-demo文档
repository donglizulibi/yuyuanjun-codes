关于router-view的初始配置

1 创立router文件夹，建立路由表文件，引入createRouter函数和需要进入路由的页面
  定义history模式，配置路由表，并导出路由实例对象
  
2 与pinia一样，在main.js文件中，调用app实例的use方法，将路由实例对象填入
  
3 在App根组件中放入router-view标签，这个标签就可以根据路由地址来显示对应的页面
  router-view组件不用另外自定义


关于vue-router的hash模式和history模式
vue作为一种单页面应用，只在一开始以初始网址发送一次请求，返回所有页面的数据
然后根据地址栏后面的路径，在路由表中匹配到相应的页面
而hash模式和history模式的区别首先在于地址栏
hash模式用井号键作为锚点把路径和域名隔开，history模式并不会隔开
所以如果页面刷新，再次发送请求的时候，锚点后面的内容不会被包括在http请求中
但是history模式没有锚点，域名和路径一起发送到服务器，会出现找不到页面的情况
所以使用history模式的话，需要在服务器端修改配置，使服务器返回初始域名的数据即可
而hash模式除了出现锚点不美观之外，对搜索引擎检索的识别度也有影响

如果碰到有多个vue项目在服务器中运行的情况，可以在createWebHashHistory或者createWebHistory中
加入字符串参数，来表示路径的前缀


关于在路由表中添加name属性，以及把router-link的跳转方式转为name
如果后续需要修改路由的地址路径，则只需要在路由表中修改，而不需要批量修改router-link

建立mock数据文件，建立api文件来发送请求获取数据，在App根组件使用suspense标签包裹

创立ListItem组件，并引入到home组件中，在home组件调用api文件的数据
然后遍历数据，并将遍历的每一项数据传递到ListItem组件中

创立Navigation组件，把router-link相关内容移到这个组件当中

在router-link标签之间跳转的时候，被选中的router-link标签会自动附上两个样式名称
router-link-active 和 router-link-exact-active
其中router-link-active是被选中的最上级路由
而router-link-exact-active是被选中具体子路由，如果没有子路由，二者就会重合

这两个样式的名称可以通过两种方法改名
第一种是在路由配置文件中，调用createRouter函数的时候
传入linkActiveClass 和 linkExactActiveClass两个属性，属性值为字符串作为新的样式名称

另一种是在router-link标签上调用exact-active-class和active-class两个标签属性
来设置新的样式名称



