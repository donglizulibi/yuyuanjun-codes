关于router-view的初始配置

1 创立router文件夹，建立路由表文件，引入createRouter函数和需要进入路由的页面
  定义history模式，配置路由表，并导出路由实例对象
  
2 与pinia一样，在main.js文件中，调用app实例的use方法，将路由实例对象填入
  
3 在App根组件中放入router-view标签，这个标签就可以根据路由地址来显示对应的页面
  router-view组件不用另外自定义


关于vue-router的hash模式和history模式
vue作为一种单页面应用，只在一开始以初始网址发送一次请求，返回所有页面的数据
然后根据地址栏后面的路径，在路由表中匹配到相应的页面
而hash模式和history模式的区别首先在于地址栏
hash模式用井号键作为锚点把路径和域名隔开，history模式并不会隔开
所以如果页面刷新，再次发送请求的时候，锚点后面的内容不会被包括在http请求中
但是history模式没有锚点，域名和路径一起发送到服务器，会出现找不到页面的情况
所以使用history模式的话，需要在服务器端修改配置，使服务器返回初始域名的数据即可
而hash模式除了出现锚点不美观之外，对搜索引擎检索的识别度也有影响

如果碰到有多个vue项目在服务器中运行的情况，可以在createWebHashHistory或者createWebHistory中
加入字符串参数，来表示路径的前缀


关于在路由表中添加name属性，以及把router-link的跳转方式转为name
如果后续需要修改路由的地址路径，则只需要在路由表中修改，而不需要批量修改router-link

建立mock数据文件，建立api文件来发送请求获取数据，在App根组件使用suspense标签包裹

创立ListItem组件，并引入到home组件中，在home组件调用api文件的数据
然后遍历数据，并将遍历的每一项数据传递到ListItem组件中

创立Navigation组件，把router-link相关内容移到这个组件当中

在router-link标签之间跳转的时候，被选中的router-link标签会自动附上两个样式名称
router-link-active 和 router-link-exact-active
其中router-link-active是被选中的最上级路由
而router-link-exact-active是被选中具体子路由，如果没有子路由，二者就会重合

这两个样式的名称可以通过两种方法改名
第一种是在路由配置文件中，调用createRouter函数的时候
传入linkActiveClass 和 linkExactActiveClass两个属性，属性值为字符串作为新的样式名称

另一种是在router-link标签上调用exact-active-class和active-class两个标签属性
来设置新的样式名称

给router-view标签添加样式可能会报错，因为要保证只有一个根元素
所以可以把样式添加在router-view外面套的div上

使用更非常规的方法实现点击不同路由，显示不同背景颜色的效果
回到路由表，可以在表中定义meta参数，来存放当下这个路径路由的信息
在这里可以存放各自页面背景颜色的样式名称
这些信息可以在slotprops的route的meta中找到
在调用meta的时候要先判断meta是否存在，如slotprops.route.meta?.class

slotprops的Component属性可以调用不同的页面给componentIs使用

建立一个show组件，并设置路由，路由要跟id相关联
把ListItem中的div标签换成可以跳转的router-link标签，对于to的设置要用模板字符串
注意样式

vue-router提供useRoute方法，注意和useRouter方法区别
前者可以调出当下页面的路由信息，后者负责路由跳转
新建一个接口，可以通过传入id来显示单个文章信息，并添加文章内容的模拟数据
使用useRoute方法返回一个对象，在params属性中，或者其他属性也可以找到当前页面的id
传入新的接口的函数，返回数据渲染到页面中

在页面中可以使用$route来调出当前的路由实例