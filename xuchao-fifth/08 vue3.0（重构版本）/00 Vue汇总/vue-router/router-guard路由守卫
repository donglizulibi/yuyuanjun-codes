在路由表中使用全局前置守卫beforeEach设置一个全局路由守卫
1 这个beforeEach函数传入一个回调函数作为参数，回调函数中有to和from两个参数
  在切换页面的时候，to和from会分别指代目标页面和初始页面的路由对象
  如果要显示路由的name，则需要在路由表中设置每个路由的name

2 如果在beforeEach函数中不添加返回值，或者return true，则表示路由守卫放行通过
  如果reture false则无法跳转到其他页面，当下的页面也无法解析

3 beforeEach是一个promise的环境，如果return一个pending状态或者是
  resolve出false的promise对象，则也等同于return false，页面无法解析
  beforeEach的回调函数可以加上async，然后在函数体内使用await

4 beforeEach函数中有第三个参数next，是旧版本router的用法
  next是一个回调函数，如果添加了第三个参数，则在beforeEach中添加return会报错
  如果添加这个参数而不调用，或者调用，但是传入false参数，如果next（false）
  则视作所有路由守卫都不放行通过，如果添加这个回调函数，不传入参数或者传入true
  则是做路由守卫放行

5 在某个判断条件之下调用next，并传入页面的路径，则在符合判断条件的时候就会跳转到相应的页面
  或者直接return到这个路径的字符串也可以达到同样的效果，但是为避免路由条件出现死循环
  next只要成为形参，旧必须至少调用一次，所以要加上else，无参数调用next，无条件放行
  而如果使用return则不用加上else，因为beforeEach函数undefined也表示无条件放行

全局解析守卫beforeResolve与全局后置守卫afterEach
1 页面刷新之后顺序就是，全局前置守卫，各个组件路由单独设置的守卫
  然后是全局解析守卫，最后是全局后置守卫

2 假如在全局前置守卫中return false，则不会进入到全局解析守卫中，但还是会执行全局后置守卫
  全局后置守卫的第三个参数不是next，而是fail，页面刷新后进行路由解析
  如果解析不成功，则返回一个对象表达守卫解析不成功的原因
  如果解析成功则显示undefined，所以如果需要在解析成功之后进行某些操作
  则!fail会显示为true，可以以此作为判断条件

给某个路由单独设置导航守卫beforeEnter
1 可以在路由表中某个页面配置中添加beforeEnter属性，属性值可以是一个回调函数
  也可以是一个包含多个回调函数的数组。这些回调函数也有to from next三个参数

2 在需要添加验证的页面配置中添加auth的meta自定义属性
  然后在beforeEnter中依据token和auth来决定是否放行
  如果不符合放行条件，则跳转到登陆页面


给某个组件单独设置导航守卫beforeRouteEnter
1 设置beforeRouteEnter需要在组件内部使用export default语法
  且beforeRouteEnter作为一个生命周期早于组件创建，甚至早于beforeCreate

2 beforeRouteEnter也有next参数，也可以设置一些关于使用该方法组件的条件
  比如设置登陆密码的条件，如果不满足就跳转到登陆页面，如果满足条件就发送请求返回该页面的数据
  可以把next的调用放在发送请求异步操作中，在next中可以传入一个回调函数
  回调函数的参数就是当前组件实例，可以根据实例的属性和请求的数据进行数据更新

给某个组件设置beforeRouteLeave和beforeRouteUpdata
1 如果某个组件页面被用来编辑资料，如果用户不小点到了其他页面可能会导致资料数据丢失
  则可以用beforeRouteLeave来跟用户确认是否离开此页面来保护数据

2 将router-demo的front/article/show页面的script标签从setup改为使用export default语法
  并添加beforeRouteLeave、beforeRouteUpdate、beforeUnmount、beforeUpdate四个生命周期
  当在同一个show页面之下改变参数的时候，页面会跳转到其他的文章内容
  此时会执行beforeRouteUpdate和beforeUpdate，其中beforeUpdate会执行两次
  而当跳转到其他页面的时候，会执行beforeRouteLeave和beforeUnmount各一次
  所以在组件内部定义的beforeRouteUpdate只会在同一个路由中改变参数的时候才会调用
  此时的所有导航守卫的执行顺序是 
  1）全局前置beforeEach  2）组件中的beforeRouteUpdate  3）全局解析beforeResolve
  4）全局后置afterEach

3 假如从a页面和b页面，给两个页面的组件内都定义了beforeRouteEnter和beforeRouteLeave
  且在路由表中给两个页面的路由配置中都定义了beforeEnter
  在路由表全局定义了beforeEach、beforeResolve和afterEach
  则从a页面跳转到b页面的时候，导航守卫的执行顺序是
  1）a组件的beforeRouteLeave  2）全局前置beforeEach  3）路由表中b组件的beforeEnter
  4）b组件的beforeRouteEnter  5）全局解析beforeResolve 6）全局后置afterEach

