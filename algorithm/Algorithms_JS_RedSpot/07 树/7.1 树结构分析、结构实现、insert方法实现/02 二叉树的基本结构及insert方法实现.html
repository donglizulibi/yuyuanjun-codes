<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      //
      class Node {
        constructor(value) {
          this.value = value;
          this.left = null;
          this.right = null;
        }
      }

      class Tree {
        constructor() {
          this.root = null;
        }

        // 如果要使用一个二叉树实例的插入方法，需要考虑这个实例是否存在根节点的问题
        // 如果不存在根节点，则插入的这个节点就自动成为根节点
        // 如果存在根节点，则从比较根节点的值和插入节点的值开始，以此比较下去
        // 找到插入节点找到某个节点的子节点位置，而这个位置是null的情况
        // 则这个位置就是插入节点的位置

        // 定义一个当父节点存在，且子节点位置的值为null的时候
        // 在子节点位置插入节点的函数
        inserNode(node, newNode) {
          // 比较父节点和新节点的大小
          if (newNode.value <= node.value) {
            if (node.left == null) {
              node.left = newNode;
            } else {
              this.inserNode(node.left, newNode);
            }
          } else {
            if (node.right == null) {
              node.right = newNode;
            } else {
              this.inserNode(node.right, newNode);
            }
          }
        }

        insert(value) {
          let newNode = new Node(value);
          console.log(this.root);
          if (this.root == null) {
            this.root = newNode;
          } else {
            this.inserNode(this.root, newNode);
          }
        }
        search(value) {}
        traverse(value) {}
        remove(value) {}
      }

      const newTreeDemo = new Tree();
      console.log(newTreeDemo);
      newTreeDemo.insert(8);
      console.log(newTreeDemo);
      newTreeDemo.insert(2);
      console.log(newTreeDemo);
      newTreeDemo.insert(3);
      newTreeDemo.insert(9);
      console.log(newTreeDemo);
    </script>
  </body>
</html>
