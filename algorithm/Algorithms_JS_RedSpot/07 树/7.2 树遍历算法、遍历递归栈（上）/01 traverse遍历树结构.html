<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <script>
      class Node {
        constructor(value) {
          this.value = value;
          this.left = null;
          this.right = null;
        }
      }

      class Tree {
        constructor() {
          this.root = null;
        }
        inserNode(node, newNode) {
          if (newNode.value <= node.value) {
            if (node.left == null) {
              node.left = newNode;
            } else {
              this.inserNode(node.left, newNode);
            }
          } else {
            if (node.right == null) {
              node.right = newNode;
            } else {
              this.inserNode(node.right, newNode);
            }
          }
        }

        insert(value) {
          let newNode = new Node(value);
          // console.log(this.root);
          if (this.root == null) {
            this.root = newNode;
          } else {
            this.inserNode(this.root, newNode);
          }
        }
        search(value) {}

        // 遍历函数要求传入一个回调函数，执行回调函数中对树结构中数据的操作
        traverseLoop(node, callback) {
          if (node == null) {
            return;
          } else {
            callback(node.value); // 前序遍历
            this.traverseLoop(node.left, callback);
            // callback(node.value); // 中序遍历
            this.traverseLoop(node.right, callback);
            // callback(node.value); // 后序遍历 可以优先找树结构中最底层的数据
          }
        }

        traverse(callback) {
          this.traverseLoop(this.root, callback);
        }

        remove(value) {}
      }

      const newTreeDemo = new Tree();
      const traverseFunc = function (value) {
        console.log("value-", value);
      };

      newTreeDemo.insert(8);
      newTreeDemo.insert(2);
      newTreeDemo.insert(3);
      newTreeDemo.insert(9);

      newTreeDemo.traverse(traverseFunc);
    </script>
  </body>
</html>
